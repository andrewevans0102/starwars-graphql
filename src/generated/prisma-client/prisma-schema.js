module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `enum affiliation {
  REBEL_ALLIANCE
  EMPIRE
}

type AggregateCharacter {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Character {
  id: ID!
  name: String!
  species: String!
  affiliation: affiliation!
  weapon: String!
}

type CharacterConnection {
  pageInfo: PageInfo!
  edges: [CharacterEdge]!
  aggregate: AggregateCharacter!
}

input CharacterCreateInput {
  id: ID
  name: String!
  species: String!
  affiliation: affiliation!
  weapon: String!
}

type CharacterEdge {
  node: Character!
  cursor: String!
}

enum CharacterOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  species_ASC
  species_DESC
  affiliation_ASC
  affiliation_DESC
  weapon_ASC
  weapon_DESC
}

type CharacterPreviousValues {
  id: ID!
  name: String!
  species: String!
  affiliation: affiliation!
  weapon: String!
}

type CharacterSubscriptionPayload {
  mutation: MutationType!
  node: Character
  updatedFields: [String!]
  previousValues: CharacterPreviousValues
}

input CharacterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CharacterWhereInput
  AND: [CharacterSubscriptionWhereInput!]
  OR: [CharacterSubscriptionWhereInput!]
  NOT: [CharacterSubscriptionWhereInput!]
}

input CharacterUpdateInput {
  name: String
  species: String
  affiliation: affiliation
  weapon: String
}

input CharacterUpdateManyMutationInput {
  name: String
  species: String
  affiliation: affiliation
  weapon: String
}

input CharacterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  species: String
  species_not: String
  species_in: [String!]
  species_not_in: [String!]
  species_lt: String
  species_lte: String
  species_gt: String
  species_gte: String
  species_contains: String
  species_not_contains: String
  species_starts_with: String
  species_not_starts_with: String
  species_ends_with: String
  species_not_ends_with: String
  affiliation: affiliation
  affiliation_not: affiliation
  affiliation_in: [affiliation!]
  affiliation_not_in: [affiliation!]
  weapon: String
  weapon_not: String
  weapon_in: [String!]
  weapon_not_in: [String!]
  weapon_lt: String
  weapon_lte: String
  weapon_gt: String
  weapon_gte: String
  weapon_contains: String
  weapon_not_contains: String
  weapon_starts_with: String
  weapon_not_starts_with: String
  weapon_ends_with: String
  weapon_not_ends_with: String
  AND: [CharacterWhereInput!]
  OR: [CharacterWhereInput!]
  NOT: [CharacterWhereInput!]
}

input CharacterWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createCharacter(data: CharacterCreateInput!): Character!
  updateCharacter(data: CharacterUpdateInput!, where: CharacterWhereUniqueInput!): Character
  updateManyCharacters(data: CharacterUpdateManyMutationInput!, where: CharacterWhereInput): BatchPayload!
  upsertCharacter(where: CharacterWhereUniqueInput!, create: CharacterCreateInput!, update: CharacterUpdateInput!): Character!
  deleteCharacter(where: CharacterWhereUniqueInput!): Character
  deleteManyCharacters(where: CharacterWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  character(where: CharacterWhereUniqueInput!): Character
  characters(where: CharacterWhereInput, orderBy: CharacterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Character]!
  charactersConnection(where: CharacterWhereInput, orderBy: CharacterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CharacterConnection!
  node(id: ID!): Node
}

type Subscription {
  character(where: CharacterSubscriptionWhereInput): CharacterSubscriptionPayload
}
`
      }
    